## Lab8 实验报告

### 练习1: 完成读文件操作的实现（需要编码）

#### 实现思路

在`sfs_io_nolock` (Line 552, `kern/fs/sfs/sfs_inode.c`) 函数中，先计算一些辅助变量，并处理越界等特殊情况，然后开始进行读取/写入操作。我们需要实现的就是这一部分。该部分分为如下三个步骤：

1. 处理起始地址所在的那一块：如果起始地址`offset`就是对齐的，那么忽略这一步。否则，计算`offset`在块内偏移`blkoff`和待操作的大小`size`。先调用`sfs_bmap_load_nolock`获取`ino`，再调用`sfs_buf_op`完成实际的读写操作。完成后，需要增加已完成的大小`alen`，缓冲区指针`buf`前移，下一个需要操作的块号`blkno`自增1，待处理的块号`nblks`自减1。
2. 处理中间连续的完整的块：对于每一个块，`size`就是块大小，`blkoff`为0。先调用`sfs_bmap_load_nolock`获取`ino`，再调用`sfs_block_op`完成实际的读写操作。完成后，需要增加已完成的大小`alen`，缓冲区指针`buf`前移，下一个需要操作的块号`blkno`自增1，待处理的块号`nblks`自减1。
3. 处理最后没有对齐的那一块：这时，`blkoff`为0，先计算`size`。如果`size=0`，这一步就不需要做了。否则，先调用`sfs_bmap_load_nolock`获取`ino`，再调用`sfs_buf_op`完成实际的读写操作。完成后，需要增加已完成的大小`alen`。由于`buf, blkno, nblks`后面不再被使用，我们无需对其进行修改。

需要注意的是，上述操作中某一项调用失败，需要立即`goto out`来结束程序，这时由于已完成的大小和用户期待的大小不同，就相当于提醒用户文件读写的操作失败。

#### 给出设计实现“UNIX的PIPE机制”的概要设计方案

### 练习2: 完成基于文件系统的执行程序机制的实现（需要编码）

#### 实现思路

#### 给出设计实现基于“UNIX的硬链接和软链接机制”的概要设计方案

- 硬链接：在文件描述符中加入一个标记位和一个指针。当一个文件是硬链接时，标记位为1，而指针则指向链接的文件；
- 软链接：直接拷贝文件对应的`inode`。
